set client_min_messages to warning;
create extension pgtelemetry cascade;
select count(*) > 0 from pgtelemetry.database_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.relation_total_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.catalog_total_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.index_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.relation_toast_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.tablespace_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.database_size;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.connections_by_application;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.connections_by_state;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.connections_by_ip_source;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.longest_running_active_queries;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > -1 from pgtelemetry.waiting_connections_by_event_type;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.locks_by_type;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.locks_by_mode;
 ?column? 
----------
 t
(1 row)

select count(*) = 1 from pgtelemetry.lock_queue_size_five_minutes_wait;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.tuple_access_stats;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.autovacuum_stats;
 ?column? 
----------
 t
(1 row)

SELECT count(*) > 0 from pgtelemetry.statement_query_rows_time;
ERROR:  pg_stat_statements must be loaded via shared_preload_libraries
SELECT count(*) > 0 from pgtelemetry.statement_query_buffers;
ERROR:  pg_stat_statements must be loaded via shared_preload_libraries
